package org.linuxmotion.livewallpaper.activities;

import java.io.File;

import org.linuxmotion.concurrent.CheckBoxLoader;
import org.linuxmotion.concurrent.ImageLoader;
import org.linuxmotion.livewallpaper.R;
import org.linuxmotion.livewallpaper.database.DataBaseHelper;
import org.linuxmotion.livewallpaper.models.AsyncCheckBox;
<<<<<<< HEAD
import org.linuxmotion.livewallpaper.models.listeners.CheckBoxClickListener;
import org.linuxmotion.livewallpaper.models.listeners.ImageClickListener;
=======
import org.linuxmotion.livewallpaper.models.CheckBoxClickListener;
import org.linuxmotion.livewallpaper.models.ImageClickListener;
import org.linuxmotion.livewallpaper.utils.LogWrapper;
>>>>>>> fragments

import android.app.ActivityManager;
import android.content.Context;
import android.os.Bundle;
import android.os.Environment;
import android.preference.PreferenceActivity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.TextView;

public class BasicFileBrowser extends PreferenceActivity {//implements OnScrollListener {
	
	private static final String TAG = BasicFileBrowser.class.getSimpleName();

	//private int mFlingState = 0;

	private DataBaseHelper mDBHelper = new DataBaseHelper();
	private CheckBoxLoader mCheckBoxHelper;
	private int mMemClass;
	
	ImageLoader mImageLoader; 
	@Override
	  public void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        
        mMemClass = ((ActivityManager) this.getApplicationContext().getSystemService(
                Context.ACTIVITY_SERVICE)).getMemoryClass();
       
        mDBHelper.initDatabase(this); // Prepare the helper
        mDBHelper.open();
        
        mImageLoader = new ImageLoader(this);
            

        
        //initCheckBoxCache(mMemClass);

        mCheckBoxHelper = new CheckBoxLoader(mDBHelper,false, mMemClass);
        
     
        File[] List = getPhotoList();
        if(List == null)
        	List = new File[0];
        
        ArrayAdapter adapter = new SimpleFileAdapter(this, List);

        setListAdapter(adapter); 
        //this.getListView().setOnScrollListener(this);
        

	}
	
	@Override
	public void onStart(){
		super.onStart();
		if(!mDBHelper.isOpen()){
			mDBHelper.open();
		}
	}
	
	
	@Override
	public void onStop(){
		super.onStop();
		mDBHelper.close();
	}
	
	@Override
	public void onDestroy(){
		super.onDestroy();
		// Close the database if it has not been closed yet
		if(mDBHelper.isOpen())mDBHelper.close();
	}

 
	/**
	 * Retrieves the list of photos to select from 
	 * 
	 * @return The files to select from
	 */
	private File[] getPhotoList() {
		File photoPath = new File(Environment.getExternalStorageDirectory().toString() + "/DCIM/Camera"); // Dont hard code this
        return photoPath.listFiles();
        
	}

<<<<<<< HEAD
=======


	private void initDiskCache() {
		  mDiskCache = new DiskLruImageCache(this, DISK_CACHE_SUBDIR, DISK_CACHE_SIZE, CompressFormat.JPEG, 50);

		
	}



	private void initMemCache() {

	     // Get memory class of this device, exceeding this amount will throw an
	        // OutOfMemory exception.
	        final int memClass = ((ActivityManager) this.getApplicationContext().getSystemService(
	                Context.ACTIVITY_SERVICE)).getMemoryClass();

	        // Use 1/8th of the available memory for this memory cache.
	        final int cacheSize = 1024 * 1024 * memClass / 8;

	        mMemoryCache = new LruCache<String,Bitmap>(cacheSize) {
	            @Override
	            protected int sizeOf(String key, Bitmap bitmap) {
	                // The cache size will be measured in bytes rather than number of items.
	                return bitmap.getRowBytes() * bitmap.getHeight();// int result permits bitmaps up to 46,340 x 46,340
	            }
	        };
	        
	     

	        // Use 1/16th of the available memory for this memory cache.
	        final int boxcacheSize = 1024 * 1024 * memClass / 16;

	        mCheckBoxCache = new LruCache<String,Boolean>(boxcacheSize) {
	            @Override
	            protected int sizeOf(String key, Boolean yana) {
	                // The cache size will be measured in bytes rather than number of items.
	                return 8;
	            }
	        };
	       String[] s = mDBHelper.getAllEntries();
	       for(int i = 0; i < s.length; i++){
	    	   
	    	  addBooleanToMemCache(s[i],true);
	       }

		
	}



	/**
	 * 
	 * @param key The key to store the Bitmap against
	 * @param bitmap The bitmap to store
	 * @return True if the bitmap was added succesfully
	 */
	public boolean addBitmapToMemoryCache(String key, Bitmap bitmap) {
	    if (getBitmapFromMemCache(key) == null) {
	    	//Log.i("BasicBrowser", "Setting mem cache file for image "+ key);
	        mMemoryCache.put(key, bitmap);
	     	return true;
	    }
	    return false;
	}
	/**
	 * 
	 * @param key The key to store the Bitmap against
	 * @param bitmap The bitmap to store
	 * @return True if the bitmap was added successfully
	 */
	public boolean addBitmapToDiskCache(String key, Bitmap bitmap) {
	    if (getBitmapFromDiskCache(key) == null) {
	    	//Log.i("BasicBrowser", "Setting disk cache file for image "+ key);
	    	mDiskCache.put(key, bitmap);
	     	return true;
	    }
	    return false;
	}
	/**
	 * 
	 * @param key The key to store the Boolean against
	 * @param bool The Boolean to store
	 * @return True if the Boolean was added successfully
	 */
	public boolean addBooleanToMemCache(String key, Boolean bool) {
	    if (key == null) {
	    	Log.i("BasicBrowser", "Add mem cache for checkbox key "+ key);
	    	
	    	return mCheckBoxCache.put(key, bool);
	    }
	    return false;
	}
	
	public Bitmap getBitmapFromMemCache(String key) {
		//Log.i("BasicBrowser", "Retriveing bitmap for "+ key);
		if(key == null)return null;
	    return mMemoryCache.get(key);
	}
	public Bitmap getBitmapFromDiskCache(String key) {
		//Log.i("BasicBrowser", "Retriveing bitmap for "+ key);
		if(key == null)return null;
	    return mDiskCache.getBitmap(key);
	}
	public Boolean getBooleanFromMemCache(String key) {
		//Log.i("BasicBrowser", "Retriveing bitmap for "+ key);
		if(key == null)return null;
	    return mCheckBoxCache.get(key);
	}

>>>>>>> fragments
	
	class SimpleFileAdapter extends ArrayAdapter<File>{
		private final Context mContext;
		private final File[] mPhotos;
		
<<<<<<< HEAD
		public SimpleFileAdapter(Context context, File[] photos) {
			super(context, R.layout.rowlayout, android.R.layout.simple_list_item_1, photos);
			
			mContext = context;
=======
		public SimpleFileAdapter(BasicFileBrowser act, File[] photos) {
			super(act.getApplicationContext(), R.layout.rowlayout, android.R.layout.simple_list_item_1, photos);
			
			mContext = act.getApplicationContext();
>>>>>>> fragments
			mPhotos  = photos;
			
		}
		
		
		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			
			
			View rowView = convertView;
			// Instatiate the objects
			TextView textView;
			ImageView imageView;
			AsyncCheckBox  selectedBox;
			if (rowView == null) {
				
			
			LayoutInflater inflater = (LayoutInflater) mContext
					.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
			rowView = inflater.inflate(R.layout.rowlayout, parent, false);

			}
			// Find the views for modification
			{
				textView = (TextView) rowView.findViewById(R.id.label);
				 imageView = (ImageView) rowView.findViewById(R.id.icon);
				 selectedBox = (AsyncCheckBox) rowView.findViewById(R.id.box);

			}
			
			// Modify the objects
			{
			String Absolutepath = mPhotos[position].getAbsolutePath();
			String fullname = mPhotos[position].getName();
			String name = fullname.substring(0, fullname.indexOf('.'));
			
				// Set the click listener
				{
					imageView.setOnClickListener(new ImageClickListener(this.getContext(),Absolutepath));
					selectedBox.setOnClickListener(new CheckBoxClickListener(mCheckBoxHelper, mDBHelper,Absolutepath));
					
				}
				// Is the file present in the database
				// Is so inform the user with the checkbox
				// Threaded to not block the UI
				{
					selectedBox.setChecked(false);// So the user wont see checks when scrolling
<<<<<<< HEAD
					mCheckBoxHelper.setChecked(selectedBox, Absolutepath); // Will set the check for real						

=======
					Boolean bool = getBooleanFromMemCache(Absolutepath);
					if(bool == null){
						mCheckBoxHelper.setChecked(mAct, mDBHelper, selectedBox, Absolutepath); // Will set the check for real						
					}else{
						LogWrapper.Logi(TAG,"Setting cached checkbox value = " + bool);
						selectedBox.setChecked(bool);
					}
>>>>>>> fragments
					
				}
			
			textView.setText(name); // remove the file type from the name
			
			//String hash = String.valueOf(((new File(Absolutepath)).hashCode()));
<<<<<<< HEAD
			mImageLoader.setImage(Absolutepath, imageView);

=======
			
	        final Bitmap bitmap = getBitmapFromMemCache(fullname);
		        if (bitmap != null) {
		        	//Log.i("BasicBrowser", "Setting cached bitmap for name = " + fullname);
		            imageView.setImageBitmap(bitmap);
		        }
		        else{	
		        	mImageLoader.download(mAct,Absolutepath, imageView);
				}
>>>>>>> fragments
	        }
			// Return the new view
			return rowView;
		}
		
		
	}





/*
	@Override
	public void onScroll(AbsListView view, int firstVisibleItem,
			int visibleItemCount, int totalItemCount) {
	
		// TODO Auto-generated method stub
		
	}

	@Override
	public void onScrollStateChanged(AbsListView view, int scrollState) {

		
		switch(scrollState){
		
		case OnScrollListener.SCROLL_STATE_FLING:{
			mImageLoader.holdTaskLoader();
			}break;
		case OnScrollListener.SCROLL_STATE_IDLE:{
			mImageLoader.releaseTaskLoader();
			}break;
		case OnScrollListener.SCROLL_STATE_TOUCH_SCROLL:{
			mImageLoader.releaseTaskLoader();
			}break;
		}
		
		
		
		
        
	}
	*/
	

}
